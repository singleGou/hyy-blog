# 函数

就是为了复用代码，将代码分模块

js 中函数不是一个特殊的类型，而是一个值



## 函数声明

在执行代码块之前，内部算法会先处理函数声明，函数声明只在它所在的代码块中可见

```js
let age = 18;
if (age > 18) {
	getAge(); // 18
	function getAge() {
		console.log(age);
	}
}
getAge(); // 报错
```



## 局部变量和全局变量

局部变量：在函数内部声明的变量，只在函数内部可见

全局变量：在任何函数之外部声明的变量，在任意函数中可见

```js
let age = 3; // 外部变量，如果没有外层函数也是全局变量

function showAge() {
  let age = 18; // 声明一个局部变量，此处会遮蔽外部的 age
  console.log(age); // 18
}

showAge();

console.log(age); // 3，局部变量在函数外部不可见
```



## 参数

可以通过参数将任意数据传递给函数

```js
// 函数 add 被声明，并带有两个参数 a，b
function add(a, b) {
  return a + b;
}
add(1, 2); // 函数 add 被调用，两个参数分别为 1，2
```

- 参数（parameter）是函数声明中括号内列出的变量

- 参数（argument）是调用函数时传递给函数的值



## 默认值

```js
// 函数参数未设置默认值
function add(a, b) {
  return a + b;
}
let result = add(1); // 只传递了一个参数
console.log(result); // NaN，参数 b 未提供，变为 undefined，相当于 1 + undefined
```

使用 `=` 为函数声明中的参数指定默认值

```js
function add(a, b = 0) {
  return a + b;
}
console.log(add(1)); // 1，使用默认值 b = 0
console.log(add(1, 2)); // 3，使用参数值 b = 2
```



## 返回值

函数都有返回值，使用 `return` 将值返回给调用代码：

```js
function add(a, b) {
  return a + b;
}
console.log(add(1, 2)); // add(1, 2) 调用函数，接收返回值 3
```

**空值的** `return` **或没有** `return` **的函数返回值为** `undefined`

```js
function foo() {}
console.log(foo() === undefined); // true

function fun() {
  return;
}
console.log(fun() === undefined); // true
```



## 函数表达式

```js
// 函数表达式允许省略函数名
let sayHi = function () {
	console.log('hello');
}
```



## 递归和堆栈

递归：函数调用自身

递归步骤：当一个函数调用自身时

递归的基础：函数的参数使任务简单到该函数不需要再进一步调用

> 任何递归函数都可以被重写为迭代的形式
>
> 递归的优点是代码更短易于维护，缺点是会占用更多的内存

```js
function pow(x, n) {
  return (n === 1) ? x : x * pow(x, n - 1);
}

console.log(pow(2, 3)); // 8
```

### 执行上下文和堆栈

**执行上下文**是一个内部数据结构，存储了有关正在运行函数的执行过程的相关信息，包含有关函数执行时的详细细节：当前控制流所在的位置、当前的变量、this 以及其他一些内部细节

一个函数调用只有一个与其相关联的执行上下文

当一个函数进行嵌套调用时：

1. 当前函数被暂停
2. 与之相关的执行上下文被一个特殊的数据结构**执行上下文堆栈**保存
3. 执行嵌套调用
4. 嵌套调用结束后，从堆栈中恢复之前的执行上下文，并从暂停的位置恢复外部函数

递归深度等于堆栈中上下文的最大数量

### 递归遍历

```js
let company = {
  sales: [
    {
      name: 'John',
      salary: 1000
    },
    {
      name: 'Alice',
      salary: 1600
    }
  ],

  development: {
    sites: [
      {
        name: 'Peter',
        salary: 2000
      },
      {
        name: 'Alex',
        salary: 1800
      }
    ],

    internals: [
      {
        name: 'Jack',
        salary: 1300
      }
    ]
  }
};

function sumSalaries(department) {
  if (Array.isArray(department)) {
    return department.reduce((prev, current) => prev + current.salary, 0);
  } else {
    let sum = 0;
    for (let subdep of Object.values(department)) {
      sum += sumSalaries(subdep);
    }
    return sum;
  }
}

console.log(sumSalaries(company)); // 7700
```

### 递归结构

递归定义的数据结构是一种部分复制自身的数据结构

#### 链表

用于快速插入/删除，链表元素是一个使用以下元素通过递归定义的对象：

- value
- next 属性引用下一个链表元素或代表末尾的 null



## Rest 参数、arguments 对象 和 Spread 语法

### Rest

rest 参数（剩余参数）用于创建可接受任意数量参数的函数，必须在参数列表的末尾

```js
function sum(a, b, ...args) {
  let sum = a + b;
  for (let arg of args) {
    sum += arg;
  }
  return sum;
}

console.log(sum(1, 2, 3, 4, 5)); // 15
```

### arguments

arguments 是一个特殊的**可迭代**的**类数组对象**，在函数中可以被访问，由于 ES6 之前不支持 rest 参数，arguments 是获取函数所有参数的唯一方法，缺点是无法使用数组方法且不能截取部分参数

```js
function fn() {
  console.log(arguments); // [Arguments] { '0': 1, '1': 2, '2': 3 }
  console.log(arguments.length); // 3
}

fn(1, 2, 3);
```

### Spread

spread 语法用于将**可迭代对象**“展开”到参数列表中

```js
Math.max(1, 2, 3); // 3
Math.max([1, 2, 3]); // NaN

// spread 语法将数组展开成参数列表形式
Math.max(...[1, 2, 3]); // 3

// spread 适用于任何可迭代对象
let str = 'hello';
let arr = [...str];
console.log(arr); // [ 'h', 'e', 'l', 'l', 'o' ]

// Array.from 也可以实现上面类似效果
let arr2 = Array.from(str);
console.log(arr2); // [ 'h', 'e', 'l', 'l', 'o' ]
```

> Spread 语法只适用于可迭代对象
>
> Array.from 适用于类数组对象，也适用于可迭代对象

和 `Object.assign` 效果相似可实现**浅拷贝**（倾向于使用 spread 语法）：

```js
let arr = [1, 2, 3];

let arr2 = Object.assign([], arr);
console.log(JSON.stringify(arr) === JSON.stringify(arr2)); // true
console.log(arr === arr2); // false

let arr3 = [...arr];
console.log(JSON.stringify(arr) === JSON.stringify(arr3)); // true
console.log(arr === arr3); // false

// 改变最外层属性不会影响原始对象
arr2[0] = 'a';
arr3[1] = 'b';
console.log(arr, arr2, arr3); // [ 1, 2, 3 ] [ 'a', 2, 3 ] [ 1, 'b', 3 ]
```

### 区分 ...

- 若 `...` 出现在函数参数列表的最后，那么它就是 rest 参数，它会把参数列表中剩余的参数收集到一个数组中
- 若 `...` 出现在函数调用或类似的表达式中，那它就是 spread 语法，它会把一个数组展开为列表



## 变量作用域和闭包

### 代码块

代码块 `{...}` 内声明的变量只在该代码块内可见

### let 和 var

For each iteration of a `for` loop with a `let` declaration, a new lexical scope is created, and a fresh binding is initialized for each variable declared in the loop head.

```js
for (let i = 0; i < 3; i++) {
  // 每次循环创建一个新的块级作用域
}
```

while 循环就不会有这个效果

```js
let i = 0;
while (i < 3) {
  setTimeout(() => {
    console.log(i); // ?
  }, 0);
  i++;
}
```

### 词法环境

#### 变量

js 中每个运行的函数、代码块以及整个脚本都有一个被称为**词法环境 [[Environment]] **的内部隐藏关联对象，由两部分组成：

1. 环境记录：存储所有局部变量作为其属性（包括一些其他信息如 this 的值）的对象
2. 对外部词法环境的引用，与外部代码相关联

一个变量只是**环境记录**这个特殊内部对象的属性，与当前正在执行的代码块/函数/脚本有关

#### 函数声明

函数和变量一样也是一个值，不同的是函数在声明的时候会被立刻初始化，这就是为什么可以在一个函数声明之前调用它，这种行为仅适用于函数声明，不适用于函数表达式：

```js
fn();
function fn() {
  console.log('hello');
}

sayHello(); // Cannot access 'sayHello' before initialization
let sayHello = function () {
  console.log('hello');
};
```

#### 内部和外部的词法环境

当一个函数在运行时，会自动创建一个新的词法环境以存储这个调用的局部变量和参数

当代码要访问一个变量时，首先会搜索内部词法环境，然后搜索更外部的环境，直到全局词法环境，找不到就会报错

#### 返回函数

```js
function makeCount() {
  let count = 0;

  return function () {
    return count++;
  };
}

let counter = makeCount();
console.log(counter()); // 0
```

### 闭包

闭包是指一个函数可以记住其外部变量并可以访问这些外部变量，除了 `new Function` 之外所有的 JavaScript 函数都自带闭包

### 垃圾回收

通常函数调用完成后，会将创建的词法环境和其中的变量删除

但是如果有一个嵌套函数在运行结束后其词法环境仍可达，它将具有引用词法环境的 `[[Environment]]` 属性

```js
function f() {
  let value = 123;

  return function() {
    console.log(value);
  }
}

let g = f(); // g.[[Environment]] 存储了对相应 f() 调用的词法环境的引用
```



## 函数对象

函数也是一个值，类型是对象

### 属性 name

```js
function fn() {}
console.log(fn.name); // fn

// 上下文命名
const sayHi = function () {};
console.log(sayHi.name); // sayHi
```

上下文命名：如果函数自己没有提供，那么在赋值中，会根据上下文来推测一个

### 属性 length

返回函数入参的个数

```js
function f1(a) {}
function f2(a, b) {}
function f3(a, b, ...more) {}

console.log(f1.length); // 1
console.log(f2.length); // 2
console.log(f3.length); // 2，rest 参数不参与计数
```

### 自定义属性

添加函数属性记录函数被调用的次数：

```js
function fn() {
  console.log('fn is called');

  fn.count++;
}
fn.count = 0;

fn();
fn();

console.log(`${fn.count} times`);
```

函数属性有时被用于替代闭包，与闭包不同的是函数属性可以被外部代码访问到：

```js
function makeCounter() {
  // let count = 0

  function counter() {
    return counter.count++;
  }

  counter.count = 0;

  return counter;
}

let counter = makeCounter();
console.log(counter()); // 0
console.log(counter.count); // 1
```

### 函数命名表达式

函数表达式可以在 function 后加一个名字，特点：

- 允许函数在内部引用自己
- 在函数外部不可见

```js
let sayHi = function fn(name) {
  if (name) {
    console.log(`hello, ${name}`);
  } else {
    fn('Jerry');
  }
};

let welcome = sayHi;
sayHi = null;

sayHi(); // 'Jerry'
// fn('Alan'); // error
```

为什么要这么做

```js
let sayHi = function (name) {
  if (name) {
    console.log(`hello, ${name}`);
  } else {
    sayHi('Jerry'); // 没有局部的 sayHi 了
  }
};

let welcome = sayHi;
sayHi = null;

welcome(); // error
```



## "new Function"

还有一种很少使用的创建函数的方法：

```js
let func = new Function ([arg1, arg2, ...argN], functionBody);
```

只有在需要从服务器获取代码或者动态地从模板编译函数时才会使用

带参数不不带参数的例子：

```js
let sum = new Function('a', 'b', 'return a + b');
console.log(fn(1, 2)); // 3

let sayHi = new Function('console.log("Hi")');
sayHi();
```

使用该种方式创建的函数无法访问外部变量，只能访问全局变量，即它的 `[[Environment]]` 指向全局词法环境：

```js
function getFunc() {
  let value = "test";

  let func = new Function('console.log(value)');

  return func;
}

getFunc()(); // error: value is not defined
```



## 调度

- setTimeout 允许将函数推迟一段时间后再执行

  使用 clearTimeout 取消

- setInterval 允许重复运行一个函数

  使用 clearInterval 取消

都会返回一个定时器标识符，在浏览器中是一个数字

```js
let timerId = setTimeout(() => console.log('never happens'), 1000);
console.log(timerId); // 定时器标识符

clearTimeout(timerId);
console.log(timerId); // 还是这个标识符（并没有因为调度被取消了而变成 null）
```

理解任务队列：

```js
for (let i = 0; i <= 5; i++) {
  setTimeout(() => {
    console.log(i, new Date()); // 每个间隔 1s 打印
  }, i * 1000);
}
```

### 嵌套的 setTimeout

周期性调度有两种方式：

1. 使用 setInterval

2. 使用嵌套的 setTimeout

   可以根据当前执行结果来进行下一次调用

```js
let delay = 1000;
let timerId = setTimeout(function request() {
  console.log('request');
  delay *= 2; // // 下一次执行的间隔是当前的 2 倍
  timerId = setTimeout(request, delay);
}, delay);
```

setTimeout 比 setInterval 能更精确地设置两次执行的间隔：

> 如果函数引用了外部变量（闭包），那么只要这个函数还存在，外部变量也会随之存在。它们可能比函数本身占用更多的内存
>
> 当不再需要使用调度函数时，最好取消它，防止内存占用
>
> ```js
> // 在调度程序调用这个函数之前，这个函数将一直存在于内存中
> setTimeout(function() {...}, 100);
> ```

### 零延时的 setTimeout

setTimeout(func, 0) 或 setTimeout(func)

在当前正在执行的脚本执行完成后，调度程序才会调用它

在浏览器环境中，零延迟实际不为 0，经过 5 重嵌套定时器之后，时间间隔被强制设定为至少 4 毫秒：

```js
let start = Date.now();
let times = [];

setTimeout(function run() {
  times.push(Date.now() - start); // 保存前一个调用的延时

  if (start + 100 < Date.now()) console.log(times); // 100 毫秒之后，显示延时信息
  else setTimeout(run); // 否则重新调度
});
```

所有的调度方法都不能保证确切的延时。例如，浏览器内的计时器可能由于许多原因而变慢：

- CPU 过载。
- 浏览器页签处于后台模式。
- 笔记本电脑用的是省电模式



## 装饰器模式和转发，call/apply

装饰器（decorator）：一个特殊的函数，接收另一个函数并改变其行为，作用：

1. 可以复用
2. 无需更改原函数
3. 可以组合多个装饰器

### call

特殊的内建函数方法：`func.call(context, ...args)` ，允许显示设置 this 的函数

```js
func(1, 2);
func.call(obj, 1, 2); // 会将 this 设置为 obj
```

```js
function sayName() {
  console.log(this.name);
}

let john = { name: 'john' };
let susan = { name: 'susan' };

sayName.call(john); // 'john'
sayName.call(susan); // 'susan'
```

### apply

`func.apply(context, args)`，args 必须是**类数组对象**

apply 比 call 可能更快，因为大多数 js 引擎在内部对其进行了优化

```js
function spy(func) {
  function wrapper(...args) {
    wrapper.calls.push(args);
    return func.apply(this, args);
  }

  wrapper.calls = [];

  return wrapper;
}

function work(...args) {
  return args.reduce((acc, item) => acc + item, 0);
}

work = spy(work);

console.log(work(1, 2, 3)); // 6
console.log(work(4, 5)); // 9

for (let args of work.calls) {
  console.log('call:' + args.join()); // "call:1,2,3", "call:4,5"
}
```

### 方法借用

```js
function hash() {
  return [].join.call(arguments); // 让 join 方法在类数组对象 arguments 的上下文中运行，也就是改变了 join 内部 this 的值
}

console.log(hash(1, 2)); // '1,2'
```

### 防抖

在给定时间后只会触发最后一次

### 节流



## 函数绑定 bind

函数内建方法：bind，语法：

```js
let bound = func.bind(context, [arg1], [arg2], ...);
```

返回结果 bound 是一个特殊的类似函数的“外来对象（exotic object）”，它可以像函数一样被调用，并且透明地将调用传递给 func 并设定 `this=context`

> 1. 绑定后无法再修改 this，即使是显示 .call(obj) 也无效
>
> 2. 每次 bind 都会生成新函数：
>
>    ```js
>    function sayHi() {
>      console.log(this.name);
>    }
>    sayHi.test = 5;
>    
>    // bind 的结果是另一个对象，它没有属性 test
>    let bound = sayHi.bind({
>      name: 'John',
>    });
>    
>    console.log(bound.test); // undefined
>    ```

```js
let user = {
  name: 'Tom',
};

function fn(phrase) {
  console.log(phrase + ', ' + this.name); // 'hello, Tom'
}

let fnUser = fn.bind(user);
fnUser('hello');
```

- 解决 this 丢失问题
- 解决调用错误对象问题

```js
let user = {
  name: 'Tom',
  sayName() {
    console.log('my name is', this.name);
  },
};

let sayName = user.sayName.bind(user);

// 可以在没有对象的情况下运行它
user.sayName(); // 'my name is Tom'

setTimeout(sayName, 1000);

// 即使 user 的值在不到 1s 内发生了改变
// sayName 还是会使用预先绑定（pre-bound）的值，改值是对旧的 user 对象的引用
user = {
  sayName() {
    console.log('another user in setTimeout');
  },
};
```

### bindAll

如果一个对象有很多方法，想把他们都传递出去，可以在一个循环中完成所有方法的绑定

将对象里所有函数的 this 永远锁死在该对象本身，无论将来怎么赋值、调用，都不会丢失上下文

```
let user = {
  name: 'Tom',
  sayName() {
    console.log('my name is', this.name);
  },
};

for (let key in user) {
  if (typeof user[key] === 'function') {
    user[key] = user[key].bind(user);
  }
}

const f = user.sayName;
f();
```

### 部分（应用）函数（Partial functions)

bind 不仅可以绑定 this，还可以绑定参数

> 为什么需要？
>
> 创建一个函数不必每次都提供一个相同的参数

```js
function mul(a, b) {
  return a * b;
}

// 这里实际没有用到 this，但是 bind 又需要，所以这里必须传入 null 之类的东西
let double = mul.bind(null, 2);

console.log(double(3)); // = mul(2, 3) = 6
```

### 没有上下文情况下的 partial

当绑定一些参数，但是不想绑定上下文 this，原生的 bind 不允许省略上下文直接跳到参数

可以实现仅绑定参数的函数：

```js
function partial(fn, ...argsBound) {
  return function (...args) {
    return fn.call(this, ...argsBound, ...args);
  };
}

let user = {
  name: 'Tom',
  say(time, phrase) {
    console.log(`[${time}] ${this.name}: ${phrase}`);
  },
};

const time = new Date().getHours() + ':' + new Date().getMinutes();
user.sayNow = partial(user.say, time);
user.sayNow('hello'); // [8:00] Tom: hello
```



## 箭头函数

- 没有 this
- 没有 arguments
- 不能使用 new 进行调用
- 没有 super

使用场景：创建一个函数并将其传递到某个地方，通常不想离开当前上下文

```js
// 使用箭头函数
let func = (a, b) => {
  return a + b;
};
// 只有一个参数可以省略括号 ()
func = a => {
  return a;
};
// 没有参数
func = () => {};
// 只有一行表达式可以省略花括号 {}
func = (a, b) => a + b;

// 函数表达式版本
let func1 = function(a, b) {
	reutrn a + b;
}
```

箭头函数自身没有 this，也没有特殊的 arguments 对象，如果访问 this，则会从外部词法环境中获取，和查找常规变量的方式相同

