import{_ as a,c as s,o as l,ag as e}from"./chunks/framework.CLzmwTRU.js";const k=JSON.parse('{"title":"盒模型","description":"","frontmatter":{},"headers":[],"relativePath":"column/CSS/03-盒模型.md","filePath":"column/CSS/03-盒模型.md"}'),n={name:"column/CSS/03-盒模型.md"};function h(t,i,r,o,p,d){return l(),s("div",null,i[0]||(i[0]=[e(`<h1 id="盒模型" tabindex="-1">盒模型 <a class="header-anchor" href="#盒模型" aria-label="Permalink to &quot;盒模型&quot;">​</a></h1><h2 id="行盒与块盒" tabindex="-1">行盒与块盒 <a class="header-anchor" href="#行盒与块盒" aria-label="Permalink to &quot;行盒与块盒&quot;">​</a></h2><p>CSS 中有几种类型的盒子，一般分为区块盒子和行内盒子</p><p>盒子有内部显示和外部显示两种类型</p><p>一般可以使用 display 属性为显示类型设置各种值</p><h2 id="外部显示类型" tabindex="-1">外部显示类型 <a class="header-anchor" href="#外部显示类型" aria-label="Permalink to &quot;外部显示类型&quot;">​</a></h2><p>block 外部显示类型</p><ul><li>盒子会产生换行</li><li>width 和 height 属性可以发挥作用</li><li>内边距、外边距和边框会将其他元素从当前盒子周围“推开”</li><li>如果未指定 width，方框将沿行向扩展，以填充其容器中的可用空间。在大多数情况下，盒子会变得与其容器一样宽，占据可用空间的 100%</li></ul><h2 id="内部显示类型" tabindex="-1">内部显示类型 <a class="header-anchor" href="#内部显示类型" aria-label="Permalink to &quot;内部显示类型&quot;">​</a></h2><p>inline 外部显示类型</p><ul><li>盒子不会产生换行</li><li>width 和 height 属性将不起作用</li><li>垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 inline 状态的盒子推开</li><li>水平方向的内边距、外边距以及边框会被应用且会把其他处于 inline 状态的盒子推开</li></ul><h2 id="什么是-css-盒模型" tabindex="-1">什么是 CSS 盒模型 <a class="header-anchor" href="#什么是-css-盒模型" aria-label="Permalink to &quot;什么是 CSS 盒模型&quot;">​</a></h2><p>CSS 盒模型整体上适用于区块盒子，行内盒子使用的只是盒模型中定义的<strong>部分</strong>行为</p><p>分为标准盒模型和替代盒模型，浏览器默认使用标准盒模型</p><h3 id="盒模型的各个部分" tabindex="-1">盒模型的各个部分 <a class="header-anchor" href="#盒模型的各个部分" aria-label="Permalink to &quot;盒模型的各个部分&quot;">​</a></h3><p>组成一个区块盒子需要：</p><ul><li>内容盒子：显示内容的区域；使用 inline-size 和 block-size 或 width 和 height 等属性确定大小</li><li>内边距盒子：使用 padding 和相关属性</li><li>边框盒子：使用 border 和相关属性</li><li>外边距盒子：使用 margin 和相关属性</li></ul><h3 id="标准盒模型" tabindex="-1">标准盒模型 <a class="header-anchor" href="#标准盒模型" aria-label="Permalink to &quot;标准盒模型&quot;">​</a></h3><p>盒子总大小 = 内容 + 内边距 + 内边框</p><blockquote><p>外边距不计入盒子的实际大小但会影响盒子在页面上所占的总空间，只会影响盒子外的空间</p></blockquote><h3 id="替代盒模型" tabindex="-1">替代盒模型 <a class="header-anchor" href="#替代盒模型" aria-label="Permalink to &quot;替代盒模型&quot;">​</a></h3><p>无需将边框和内边距相加，即可获得盒子的实际大小</p><p>要为某个元素使用替代盒模型：<code>border-sizing: border-box</code></p><p>一般开发会在所有元素中使用替代盒模型：</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">html</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  box-sizing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">border-box</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">::before</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">::after</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  box-sizing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">inherit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="外边距、内边距和边框" tabindex="-1">外边距、内边距和边框 <a class="header-anchor" href="#外边距、内边距和边框" aria-label="Permalink to &quot;外边距、内边距和边框&quot;">​</a></h2><h3 id="外边距" tabindex="-1">外边距 <a class="header-anchor" href="#外边距" aria-label="Permalink to &quot;外边距&quot;">​</a></h3><p>外边距是盒子周围一圈看不到的空间，会把其他元素退推离盒子</p><p>属性值可正可负，设置负值会导致盒子与页面上的其他内容重叠</p><p>外边距总是在计算可见部分后额外添加</p><h3 id="外边距折叠" tabindex="-1">外边距折叠 <a class="header-anchor" href="#外边距折叠" aria-label="Permalink to &quot;外边距折叠&quot;">​</a></h3><p>根据外边距相接触的两个元素是正边距还是负边距，结果会有所不同：</p><ul><li>两个正外边距将合并为一个外边距。其大小等于最大的单个外边距</li><li>两个负外边距会折叠，并使用最小（离零最远）的值</li><li>如果其中一个外边距为负值，其值将从总值中<em>减去</em></li></ul><h3 id="边框" tabindex="-1">边框 <a class="header-anchor" href="#边框" aria-label="Permalink to &quot;边框&quot;">​</a></h3><p>设置所有边得宽度、样式或颜色：</p><ul><li>border-width</li><li>border-style</li><li>border-color</li></ul><h3 id="内边距" tabindex="-1">内边距 <a class="header-anchor" href="#内边距" aria-label="Permalink to &quot;内边距&quot;">​</a></h3><p>内边距不能为负数</p><p>任何应用于元素的背景都会显示在内边距后面</p><h2 id="display-inline-block" tabindex="-1">display: inline-block <a class="header-anchor" href="#display-inline-block" aria-label="Permalink to &quot;display: inline-block&quot;">​</a></h2><p>如果不希望项目换行，但又希望它使用 <code>width</code> 和 <code>height</code> 值并避免出现重叠现象</p><ul><li>设置 <code>width</code> 和<code>height</code> 属性会生效</li><li><code>padding</code>、<code>margin</code> 和 <code>border</code> 会推开其他元素</li></ul>`,42)]))}const u=a(n,[["render",h]]);export{k as __pageData,u as default};
